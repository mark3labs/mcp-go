// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/hooks.go.tmpl
package server

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
)

// OnBeforeAnyHookFunc is a function that is called after the request is
// parsed but before the method is called.
type OnBeforeAnyHookFunc func(id any, method mcp.MCPMethod, message any)

// OnAfterAnyHookFunc is a hook that will be called after the request
// successfully generates a result, but before the result is sent to the client.
type OnAfterAnyHookFunc func(id any, method mcp.MCPMethod, message any, result any)

// OnErrorHookFunc is a hook that will be called when an error occurs,
// either during the request parsing or the method execution.
type OnErrorHookFunc func(id any, method mcp.MCPMethod, message any, err error)

{{range .}}
type OnBefore{{.HookName}}Func func(id any, message *mcp.{{.ParamType}})
type OnAfter{{.HookName}}Func func(id any, message *mcp.{{.ParamType}}, result *mcp.{{.ResultType}})
{{end}}

type Hooks struct {
	OnBeforeAny      []OnBeforeAnyHookFunc
	OnAfterAny       []OnAfterAnyHookFunc
	OnError          []OnErrorHookFunc
{{- range .}}
	OnBefore{{.HookName}} []OnBefore{{.HookName}}Func
	OnAfter{{.HookName}}  []OnAfter{{.HookName}}Func
{{- end}}
}

func (c *Hooks) AddBeforeAny(hook OnBeforeAnyHookFunc) {
	c.OnBeforeAny = append(c.OnBeforeAny, hook)
}

func (c *Hooks) AddAfterAny(hook OnAfterAnyHookFunc) {
	c.OnAfterAny = append(c.OnAfterAny, hook)
}

func (c *Hooks) AddOnError(hook OnErrorHookFunc) {
	c.OnError = append(c.OnError, hook)
}

func (c *Hooks) beforeAny(id any, method mcp.MCPMethod, message any) {
	if c == nil {
		return
	}
	for _, hook := range c.OnBeforeAny {
		hook(id, method, &message)
	}
}

func (c *Hooks) afterAny(id any, method mcp.MCPMethod, message any, result any) {
	if c == nil {
		return
	}
	for _, hook := range c.OnAfterAny {
		hook(id, method, &message, result)
	}
}

func (c *Hooks) onError(id any, method mcp.MCPMethod, message any, err error) {
	if c == nil {
		return
	}
	for _, hook := range c.OnError {
		hook(id, method, message, err)
	}
}

{{- range .}}
func (c *Hooks) AddBefore{{.HookName}}(hook OnBefore{{.HookName}}Func) {
	c.OnBefore{{.HookName}} = append(c.OnBefore{{.HookName}}, hook)
}

func (c *Hooks) AddAfter{{.HookName}}(hook OnAfter{{.HookName}}Func) {
	c.OnAfter{{.HookName}} = append(c.OnAfter{{.HookName}}, hook)
}

func (c *Hooks) before{{.HookName}}(id any, message *mcp.{{.ParamType}}) {
	c.beforeAny(id, mcp.{{.MethodName}}, message)
	if c == nil {
		return
	}
	for _, hook := range c.OnBefore{{.HookName}} {
		hook(id, message)
	}
}

func (c *Hooks) after{{.HookName}}(id any, message *mcp.{{.ParamType}}, result *mcp.{{.ResultType}}) {
	c.afterAny(id, mcp.{{.MethodName}}, message, result)
	if c == nil {
		return
	}
	for _, hook := range c.OnAfter{{.HookName}} {
		hook(id, message, result)
	}
}
{{- end -}}
