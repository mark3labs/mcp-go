// Code generated by `go generate`. DO NOT EDIT.
// source: server/internal/gen/hooks.go.tmpl
package server

import (
	"context"

	"github.com/mark3labs/mcp-go/mcp"
)

type HookContext interface{
	IsHookContext()
}

type ChainedHookContext struct{
	HookContexts []HookContext
}

func (*ChainedHookContext) IsHookContext()  { }

type Hook interface {
	CreateHookContext() HookContext
	GetHookContext() HookContext
	//RegisterSession is a hook that will be called when a new session is registered.
	RegisterSession(ctx context.Context, session ClientSession)
	// OnBeforeAny is a function that is called after the request is
	// parsed but before the method is called.
	BeforeAny(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any)
	// OnSuccess is a hook that will be called after the request
	// successfully generates a result, but before the result is sent to the client.
	OnSuccess(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any, result any)
	// OnError is a hook that will be called when an error occurs,
	// either during the request parsing or the method execution.
	OnError(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any, err error)
	BeforeInitialize(ctx context.Context, hookContext HookContext, id any, message *mcp.InitializeRequest)
	AfterInitialize(ctx context.Context, hookContext HookContext, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult)
	BeforePing(ctx context.Context, hookContext HookContext, id any, message *mcp.PingRequest)
	AfterPing(ctx context.Context, hookContext HookContext, id any, message *mcp.PingRequest, result *mcp.EmptyResult)
	BeforeListResources(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourcesRequest)
	AfterListResources(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult)
	BeforeListResourceTemplates(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourceTemplatesRequest)
	AfterListResourceTemplates(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult)
	BeforeReadResource(ctx context.Context, hookContext HookContext, id any, message *mcp.ReadResourceRequest)
	AfterReadResource(ctx context.Context, hookContext HookContext, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult)
	BeforeListPrompts(ctx context.Context, hookContext HookContext, id any, message *mcp.ListPromptsRequest)
	AfterListPrompts(ctx context.Context, hookContext HookContext, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult)
	BeforeGetPrompt(ctx context.Context, hookContext HookContext, id any, message *mcp.GetPromptRequest)
	AfterGetPrompt(ctx context.Context, hookContext HookContext, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult)
	BeforeListTools(ctx context.Context, hookContext HookContext, id any, message *mcp.ListToolsRequest)
	AfterListTools(ctx context.Context, hookContext HookContext, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult)
	BeforeCallTool(ctx context.Context, hookContext HookContext, id any, message *mcp.CallToolRequest)
	AfterCallTool(ctx context.Context, hookContext HookContext, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult)
}

type ChainedHook struct {
	Hooks []Hook
	HookContext HookContext
}

func (h *ChainedHook) Add(hook Hook) {
	h.Hooks = append(h.Hooks, hook)
}

func (h *ChainedHook) CreateHookContext() HookContext {
	if h == nil {
		return &ChainedHookContext{}
	}

	chainedHookContext := &ChainedHookContext{}
	chainedHookContext.HookContexts = make([]HookContext, 0)
	for _, hook := range h.Hooks {
		chainedHookContext.HookContexts = append(chainedHookContext.HookContexts, hook.CreateHookContext())
	}
	h.HookContext = chainedHookContext
	return chainedHookContext
}

func (h *ChainedHook) GetHookContext() HookContext {
	return h.HookContext
}

func (h *ChainedHook) RegisterSession(ctx context.Context, session ClientSession) {
	if h == nil {
		return
	}

	for _, hook := range h.Hooks {
		hook.RegisterSession(ctx, session)
	}
}

func (h *ChainedHook) BeforeAny(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any) {
	if h == nil {
		return
	}

	for _, hook := range h.Hooks {
		hook.BeforeAny(ctx, hookContext, id, method, message)
	}
}

func (h *ChainedHook) OnSuccess(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any, result any) {
	if h == nil {
		return
	}

	for _, hook := range h.Hooks {
		hook.OnSuccess(ctx, hookContext, id, method, message, result)
	}
}

func (h *ChainedHook) OnError(ctx context.Context, hookContext HookContext, id any, method mcp.MCPMethod, message any, err error) {
	if h == nil {
		return
	}

	for _, hook := range h.Hooks {
		hook.OnError(ctx, hookContext, id, method, message, err)
	}
}

func (h *ChainedHook) BeforeInitialize(ctx context.Context, hookContext HookContext, id any, message *mcp.InitializeRequest) {
	if h == nil {
		return
	}

	for _, hook := range h.Hooks {
		hook.BeforeInitialize(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterInitialize(ctx context.Context, hookContext HookContext, id any, message *mcp.InitializeRequest, result *mcp.InitializeResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterInitialize(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforePing(ctx context.Context, hookContext HookContext, id any, message *mcp.PingRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforePing(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterPing(ctx context.Context, hookContext HookContext, id any, message *mcp.PingRequest, result *mcp.EmptyResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterPing(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeListResources(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourcesRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeListResources(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterListResources(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourcesRequest, result *mcp.ListResourcesResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterListResources(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeListResourceTemplates(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourceTemplatesRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeListResourceTemplates(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterListResourceTemplates(ctx context.Context, hookContext HookContext, id any, message *mcp.ListResourceTemplatesRequest, result *mcp.ListResourceTemplatesResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterListResourceTemplates(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeReadResource(ctx context.Context, hookContext HookContext, id any, message *mcp.ReadResourceRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeReadResource(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterReadResource(ctx context.Context, hookContext HookContext, id any, message *mcp.ReadResourceRequest, result *mcp.ReadResourceResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterReadResource(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeListPrompts(ctx context.Context, hookContext HookContext, id any, message *mcp.ListPromptsRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeListPrompts(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterListPrompts(ctx context.Context, hookContext HookContext, id any, message *mcp.ListPromptsRequest, result *mcp.ListPromptsResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterListPrompts(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeGetPrompt(ctx context.Context, hookContext HookContext, id any, message *mcp.GetPromptRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeGetPrompt(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterGetPrompt(ctx context.Context, hookContext HookContext, id any, message *mcp.GetPromptRequest, result *mcp.GetPromptResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterGetPrompt(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeListTools(ctx context.Context, hookContext HookContext, id any, message *mcp.ListToolsRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeListTools(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterListTools(ctx context.Context, hookContext HookContext, id any, message *mcp.ListToolsRequest, result *mcp.ListToolsResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterListTools(ctx, hookContext, id, message, result)
	}
}

func (h *ChainedHook) BeforeCallTool(ctx context.Context, hookContext HookContext, id any, message *mcp.CallToolRequest) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.BeforeCallTool(ctx, hookContext, id, message)
	}
}

func (h *ChainedHook) AfterCallTool(ctx context.Context, hookContext HookContext, id any, message *mcp.CallToolRequest, result *mcp.CallToolResult) {
	if h == nil {
		return
	}
	for _, hook := range h.Hooks {
		hook.AfterCallTool(ctx, hookContext, id, message, result)
	}
}
